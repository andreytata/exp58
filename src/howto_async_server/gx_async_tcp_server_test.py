#
# coding: utf-8

# root|
# name|slot---obj1|
#             tx2d|slot---code {"code":"texture2d","args":[23,11,"jabba.jpg"]}
#                          _| state = "refresh"
#                          x| 23           "rw"
#                          y| 11           "rw"
#                    texture| "jabba.jpg"  "rw"
#                    opeglid| 0            "r"
#
# Такая организация похожа на стек вызовов конструктора, но растянутый во времени.
# Если производится SET(x, 15) то в инвалид окрасится только значение opeglid, до
# момента вызова его GET, "opeglid"?"code" и будет рассматриваться как тот функтор,
# который и будет вызван для вычисления его правильного значения. Сылки на входящие
# значения за пределами "code", это не только лишние указатели в памяти, но и потеря
# быстродействия. Грубо выражаясь, если значение root.obj1.tx2d.x, должно автоматически
# изменяться, при изменении значения какого либо другого поля в графе зависимостей,
# то в это поле нужно установить другой объект кода который произведёт установку нового
# значения obj1.tx2d.x через SET(root.obj1.tx2d.x, 15), или запланирует вызов себя для
# получения нового значения "x" root.obj1.tx2d.x через выражение GET(где.этот.функтор.значение)
# При этом нас не беспокоит вопрос чистоты выбранной "модели вычислений" а только вопрос
# "знает ли" этот функтор "путь к переменной" или новое выражение знает путь к "code".
# Фактически, это  SET(root.obj1.tx2d.x, DEP(где.этот.функтор.и.где.это.значение.в.функторе))
# Классическое внедрение зависимости. Но, не всё так просто. Если объект, с которым связано
# значение "х" был изменён, или был изменён любой из слотов по пути к этому объекту, то объект
# root.obj1.tx2d.x должен получить свой сигнал об инвалидности ( покраску ). Возникает дикое
# желание запретить изменение содержимого слотов вдоль пути, прямо в момент внедрения зависимости!
# Можно даже инкрементить и декрементить этот запрет по мере внесения и удаления зависимостей.
# Но эта полумера приведёт только к очередной проблеме: отсутствие адреса источника зависимости
# при диагностике, и отсутсвие возможности свернуть в файл зависимость, обращение к которой не
# потеряло актуальность, но свёртка происходит по причине дефицита ОЗУ (превышение лимита по ОЗУ).
# Свёртка любой активной ветки по причине дефицита ОЗУ, это тупое удаление веток, с сериализацией
# покраски, даже без сигналов инвалидации вдоль графа зависимости. Предпочтение отдаётся веткам,
# вдоль которых наблюдается минимальная активность по операции SET. Таким образом свёртка прокрасит
# в инвалид только root.obj1.tx2d.x, но не root.obj1.tx2d.opeglid, который продолжит использоваться.
# Проблема в том, что для такой свёртки надо точно знать, каких именно узлов свёртка коснётся.
# Целостность графа не нарушится, поскольку любой SET в свёрнутую ветку немедленно обнаружит
# "заглушку свёртки" и имя "файла свёртки", откуда и десериализует ветку, неважно если в процессе
# будут свёрнуты другие ветки, по причине всё того-же дефицита ОЗУ.
# 
# Проблема путей не устранится до уничтожения путей. Возможно ли программировать граф зависимостей
# через "внедрение зависимостей", и при этом обходится без путей? Пробуем создать приложение, как
# инстанцию класса приложение, разместив в нём переменные предопределенных GDOM типов. Импортируем
# в него GDOM деревья с константными путями, у которых сменяются только листья, но не изменяются
# пути ведущие к ним. Иммутабельные пути конечно дают не малую экономию памяти, но не решают вопрос
# в "общем" виде. Как вариант остаётся ГРАФИЧЕСКОЕ программирование, путём таскания иконок с узлами
# (плагинами вычислительного графа) и соединение их стрелочками - графическим представлением связей
# вычислительного графа. Ну очень красиво, только никак не объектно-ориентированно и не прототипно
# ориентированно. Более того, ГРАФИЧЕСКОЕ представление не станет таковым, как его не крути, если
# в нём не появятся средства управления "стрелочками" на этапе инстанциирования готовых фрагментов
# вычислительного графа, в конкретном "окружении" (environment). Ну и средств формализации описания
# этого "окружения" (environment). А определение соответствия, динамически изменяющегося окружения,
# определенному "формальному шаблону", и будет одним из средств инвокации такой перелинковки. Без
# путей и типов узлов сложно, или невозможно, представить себе формализацию окружения. Например:
#   root(dict derived)
#   name|slot-+-obj1(vvtg derived)
#               tx2d|slot-+-code {"code":"texture2d","args":[23,11,"jabba.jpg"]} (tx2d derived)
#                       ---       _| state = "refresh"
#                       -->       x| 23           "rw"
#                       -->       y| 11           "rw"
#                       --> texture| "jabba.jpg"  "rw"
#                       <-- opeglid| 0            "r"
# Этот фрагмент графа можно снабдить инспектирующим кодом, который ожидает следующих соответствий:
# ( моё окружение это инстанция dict или инстанция потомка dict, в котором существует поле "name",
#  в котором расположена инстанция vvtg или потомка vvtg, в котором под именем "tx2d" размещается
#  инстанция типа tx2d или инстанция потомка типа tx2d, у которого в поле с именем "texture" будет
#  размещено точное значение "jabba3.jpg" ).
#   *   (dict+)
#   name|slot-+- * (vvtg+)
#              tx2d|slot-+- *(tx2d+)
#                       --> texture| "jabba3.jpg"
# Как бы там ни было, код такой проверки должен стартовать каждый SET каждого задействованного поля.
# Так как каждое из значений может быть доступно для SET через несколько альтернативных путей, то
# указатель на реактор должен размещаться в каждом доступном для SET элементе, и должен удаляться
# из всех теряемых, из за SET, "путей". Это набор пост-SET реакторов. В общем случае SET, действие
# которого не встретило принципиальных препятствий, должен вызвать "извлечение" всех аттомарных
# реакторов установленых опять-же вдоль формального пути, выполнить собственно SET, и вызвать все
# атомарные реакторы в элементе над которым уже выполнился этот SET. Ниже рассматривается понятие
# набора пре-GET условий, - это тоже механизм производящий покраску графа с использованием "путей".
# Интерфейс с передачей сигнала более общее решение проверки условия, чем поэлементная покраска в
# списках пост-SET. Хотя оба метода требуют одинаковых затрат по памяти, второй способ несколько
# быстрее. 

# Можно высказать гипотезу о том, что у одних и тех-же элементов графа зависимости может быть по
# одному пути в каждом аспекте формализации вычислительного графа (сформулировано коряво, но надо
# над этим вопросом серьёзно подумать). Например, можно рассматривать граф каждого аспекта как DAG,
# каждому из узлов которого поставлены в соответствие узлы DG (графа зависимостей). При такой схеме
# немедленно возникает вопрос каким образом маркированы и организованы узлы DG, и как их отыскать,
# однозначно идентифицировать, перед тем как связать с DAG аспекта. Если для идентификации узлов
# DG, нам снова понадобятся пути, это не исходная точка рассуждений, а новая область в которой есть
# отдельный интерфейс адресации в группе потенциально воссоздаваемых узлов DG, с которым ознакомлен
# набор классов предназначенный для операций с узлами DAG. Что бы не представлял из себя путь в DG
# это всё равно набор узлов, в котором все под-узлы можно разместить от выхода до входа в цепочки
# 

# Компромиссное решение предполагает внесение в динамические пути состояния "неизменный" (const).
# Слот при этом не сможет получить нового значения, пока "константность" не будет снята со слота.
# Как это выглядит реализационно? Начинаем с внедрения зависимости. Пусть в вычисляющем узле "N", 
# расположено входящее поле "X", с начальным значением "none". После операции SET(N.X, path), узел
# N или только его выходящее значение, автоматически получает сигнал "инвалид". Это в свою очередь
# распространяет волну покраски сигналом "инвалид" графа зависимостей. В случае, если N.X является
# строго типизированным, до этого процесса обязательно запускается проверка на соответствие типа.
# Но если в качестве значения допускается "путь", соответствие типа нужно проверять между слотом X
# и конечным слотом "path". Это спровоцирует сторонний эффект - инспекцию каждого из сегментов пути
# от начала пути и до его конца. Оставить какой-ни-попадя-путь, тоже можно. Вдруг тип значения, на
# другом конце пути, будет назначен позже, но до начала вычислений в графе по запросу GET. Ошибка
# SET(N.X, path) - "ошибка типа" будет возбуждена немедленно, если значение типа "путь" запрещено
# в принципе. Если значение типа "путь" разрешено устанавливать в N.X, то операция SET(N.X, path)
# завершится успехом, вне зависимости от того, что за объект будет обнаружен на другом конце path.
# Но если, на момент вычисления выходящего значения узла, тип окажется неподдерживаемым, то "ошибка
# типа" станет частью диагностического сообщения выходящего значения узла N, и распространится на
# любой входящий GET. Если, для корректного вычисления выходящих значений узла N, по входящему GET,
# нужно предварительно произвести некоторое количество операций SET|GET или каких либо других, то
# такая простыня заданий может быть прикреплена к узлу, для немедленного или "ленивого" выполнения.
# Это пред-условия вычисления. Линковка путей ко всем входящим значениям, есть разновидность такого
# пред-условия. Естественно, что разрушение уже слинкованного пути, не только вычищает его остаток
# из графа зависимостей, но и добавляет "сломанную" часть пути в список "предусловий" вычисления.
# и в этом случае очень интересна причина разрушения пути. А это может быть как свёртка поддерева
# в файл, для освобождения места в ОЗУ, так и замена значения в слоте. Пути порванные "свёрткой",
# добавляются в список пред-условий вычисления по GET, но свёртка не станет инициировать волновик
# инвалидации по выходящему значению. Обратный процесс, когда любой входящий в "свёрнутую" ветку
# SET или GET инициирует восстановление ветки из свёртки, должен найдти "объект-рубец" оставленный
# свёрткой, где окажутся указатели на объекты разрушенных свёрткой путей-зависимостей. Всё это
# нужно для того, чтобы не был пропущен входящий в ветку SET, который может нести значение в поле,
# декларированное как входящее значение для любого из этих "путей". Термин "объект-рубец" не совсем
# подходящее название. Если представить себе некий гигантский граф зависимостей, и обвести все его
# узлы воображаемой границей, затем отсечь часть графа стараясь объединить узлы в группы, пересекая
# как можно меньше рёбер. Такая вот часть графа, может рассматриваться как единый вычислительный
# узел графа, где все пересеченные входящие и выходящие связи становятся соответственно входящими и
# выходящими значениями такого композитного узла. Конечно предпочтительнее всего, никогда не резать
# граф по иммутабельным рёбрам. Это как-бы косвенная рекомендация объединять в композитный узел все
# узлы объединеные общим временем жизни, критерием свёртки и развертки. Еквивалентные группы узлов
# нужно выделять в первую очередь. Такие группы имеют общий, по определению, ИНТЕРФЕЙС линковки.

# Объект текстуры это узел графа зависимостей. (Входящее поле iN)
#     i0 - имя текстуры                  { "file", "images/texture_name.png" }
#     i1 - объект рисующего устройства   { "glsl", 0 }
#     i2 - размеры текстуры              { "uint" , { 512, 512 } }
#     o0 - id текстуры 0
#     Состояние 1, "до загрузки на видео-устройство", содержит слот файла (hardref)
#     Состояние 2, "до загрузки на видео-устройство", удаляет состояние 1, вместе со слотом файла,
#     Состояние 3, "состояние ожидания очистки с устройства" после потери всех путей, пре-GC
#     Для попадания объекта в GC, он должен потерять все ссылки во всех "видах" модели.
#     Текстура это одно из имён в словаре текстур  { "tx2d", ... }
#     Модель.Вид может содержать эту текстуру, но вид не нужен до получения пересечения объекта
#     "физическая модель камеры" и объекта "модель вид сфера опережающей подгрузки файлов вида"
#     Модель.Вид, фактически содержит поле текст, по которому может быть построен вид, который
#     создаст объект текстуру, объект геометрию и объект шейдер, при поступлении определённого
#     сигнала и разрушит этот вид при поступлении второго сигнала. После чего вид мижно будет
#     пересоздать по этому полю текст. Если текст это имя файла, то схема не будет отличаться
#     от схемы взаимодействия текстура-файл текстуры.
# GET_WEAK_REF_TO(name)     => slot with weak даёт гостевой слот, с сигналом о потере всех ссылок
#                              и с сигналом об изменении содержимого ( weak deps ).
# GET_HARD_REF_TO(name)     => slot with hard ref на объект, с сигналом об изменении содержимого
# FOR_EACH(proc*)           => apply visitor to each item in object lo_key hi_key
# FOR_EACH_ENUM(enum_proc*) => делать что либо на стороне объекта, получая ключ, и флаги первый,
#                              последний;
# AT(name, proc*), AT(key, proc*);
# code может быть заменён на node, где node может иметь интерфейс как списка, так и словаря.
# Семантика for_each(proc*) for_each_enumerate(name_proc*) for_each_enumerate(key_proc*), итд. -
# обозначает, что некоторые действия будут производиться над атрибутами, принадлежащими конкретному
# узлу, непосредственно и стеково на "приватной территории" этого узла, на уровне непосредственого
# (прямого, direct) взятия указателей на данные атрибутов. Это низкоуровневый интерфейс, например
# для инспектирования данных узла. Вся ответственность за инициирование инвалидации ложится при этом
# на того потомка "proc" или "key_proc", который был внедрён в узел для выполнения операции. Узел не
# станет отслеживать последствий такого "прямого" вмешательства, это позволяет выполнять операции
# чтения/записи значений быстро (т.е игнорируя правила DG). Но вся ответственность за инвокацию
# инвалидации ложится на этот же код "прямого" вмешательства. Такие операции выгодны за счет того,
# что не требуют предварительного дублирования слотов и манипуляций со счетчиками ссылок.
# Сигнал о разрушении пути, с докладом к инстанции пути.

# Слоты и пути как узлы чистого DG:   
#   - SLOT это DG узел, запись в поле данных которого, приводит к инвалидации зависящих от него узлов.
#     SLOT-уникальный объект графа зависимостей, время жизни которого контролируется стеком вызовов
#     SLOT-всегда подразумевается, но никогда не указывается в DG через явное объявление
#   - PATH, это DG узел, выходящее значение которого находится в прямой зависимости от всех проходимых
#     этим путем узлов, что должно выражать его конструкцию как вектор DG узлов, в котором каждый
#     последующий узел находится в зависимости как от предыдущего узла, так и от достигнутого им
#     слота. Каждый path::segm, будет состоять из указателя на path, указателя на текущий узел
#     (равный по умолчанию NULL-указателю) и слота с указателем на gdom-объект используемый в
#     качестве "ключа". Изменение объекта на который указывает PATH приводит к инвалидации всех
#     зависящих от PATH-узла объектов. Введение скрытого (как и SLOT) path::segm узла, обусловлено
#     необходимостью сокрывать как существование SLOT узлов, так и их уникальное поведение.
#   - WEAK это DG узел, в котором содержится указатель на объект задаваемый PATH. Это объявляемый
#     явно (как и любой другой DG узел) code-объект. Изменение PATH, как и изменение в значении
#     указываемого через PATH объекта, инициирует инвалидацию всех зависящих от WEAK-узла объектов
#   - Basic virtual method of each gdom object, is query FOR_ITEM(gdom*, gx::proc*)
#     НЕ ИЗВЛЕЧЕНИЕ КОПИЙ ДАННЫХ ДЛЯ ОБРАБОТКИ, А ИНЖЕКТИРОВАНИЕ АЛГОРИТМА НА СТОРОНУ ХРАНИЛИЩА.
#     АЛГОРИТМ МОЖЕТ БЫТЬ НЕ В КУРСЕ КОНКРЕТНОГО УСТРОЙСТВА ВИЗИТИРУЕМОГО КЛАССА, НО ОЗНАКОМЛЕН
#     С ПУБЛИЧНЫМИ ИНТЕРФЕЙСАМИ ВСТРОЕННЫХ ТИПОВ ДАННЫХ, ЧТО ПОЗВОЛЯЕТ ЕМУ ЧИТАТЬ И ЗАПИСЫВАТЬ
#     ИХ ЗНАЧЕНИЯ. Случай, когда визитору "code"-узла известен точный класс "code" узла, который
#     он визитирует, - скорее исключение, чем правило. Самый общий случай, это когда визитор
#     полностью в курсе устройства базовых встроенных типов, таких как имя, слот, словарь слотов,
#     список слотов, none но при визитировании типов "buff" и "code", визитор всегда работает с их
#     потомками, и может манипулировать с их состоянием только в рамках абстрактного интерфейса.




from socket import socket, AF_INET, SOCK_STREAM
from json import loads, dumps
from random import randint as rand
from time import sleep, time
import os
import traceback, pdb, sys

global_host_port = ( '192.168.0.105', 4680 )
#global_host_port = ( '127.0.0.1', 4680 )
test_root_dir    = os.path.split(__file__)[0]
os.chdir(test_root_dir)
print test_root_dir
print os.getcwdu()


class session:
    def __init__(self, host, port):
        self.socket = None
        self.server = (host, port)
        self.state = session.disconnected
    
    def send_json(self, json_text):
        return self.state.send(self, json_text)
    
    def send(self, msg):
        return self.state.send(self, dumps( dict(value=msg) ) )
    
    def recv(self):
        return self.state.recv(self)

    class disconnected:

        @staticmethod
        def send(sess, msg):
            sess.socket = socket( AF_INET, SOCK_STREAM )
            sess.socket.connect( sess.server )
            sess.state = session.ready_send
            return sess.state.send( sess, msg )
        
        @staticmethod
        def recv(sess):
            raise BaseException("Unexpected RECV in DISCONNECTED state")
        
    class ready_send:

        @staticmethod
        def send(sess, msg):
            size_type = "J%03X" % len(msg)
            sess.socket.send(size_type + msg)
            sess.state = session.wait_echo
            return sess.state.recv(sess)
        
        @staticmethod
        def recv(sess):
            raise BaseException("Unexpected RECV in READY_SEND state")
        
    class wait_echo:
        
        @staticmethod
        def send(sess, msg):
            raise BaseException("Unexpected SEND in WAIT_ECHO state")
        
        @staticmethod
        def recv(sess):
            echo = sess.socket.recv(4096)
            if echo:
                sess.state = session.ready_send
            return echo

    def send_test(self):
        if not hasattr(self,"test_dict"):
            setattr(self, "test_dict", dumps( dict\
                ( DICT01   = dict( arg1=11, arg2=12 )
                , LIST01   = ["string argument", 1.0, 1]
                , FLOAT1   = 0.011
                , FLOAT2   = 1.0
                , INT01    = 13
                , STRING01 = "Hello some ascii"
                )
                , sort_keys=True, indent=4, separators=(',', ': ')
                )
            )
    def close(self):
        self.tcp_socket.close()
        self.state = sess.disconnected

def send_test_file(fname):
    sess = session( global_host_port[0], global_host_port[1] )
    f = file(fname)
    buff = f.read()
    # test = loads(buff)
    return sess.send_json(buff)

def send_random_numbers(times):
    sess = session( global_host_port[0], global_host_port[1] )
    pack = 0
    numb = times
    while numb:
        if times: numb -= 1  
        begin_send_time = time()
        packets = rand(1, 100)
        pack += 1
        for i in xrange(packets):
            msg = "<%s>hello%s" % (pack,i)
            echo = sess.send(msg)
            if not "<Ok>" != echo:
                print msg, "=>", echo
        SEND_TIME = time() - begin_send_time
        print "RECV PACKETS", packets
        print "PACK_TIME", SEND_TIME/packets


# Главный алгоритм в работе с именованым атрибутом. Интерфейс данных ( интерфейс чтения/интерфейс
# записи - не важно. Главное в этом интерфейсе сожрать ввод. Просто JSON. Создать интерфейс, дать
# в интерфейс сообщение - плоский JSON (одна из кнопок ввода). Тут есть некая ассимметрия. Чтение
# генерирует JSON самостоятельно, просто выбрасывая текст. Запись принимает уже проверенный JSON -
# - вершину дерева для двусвязного визитирования. GATE - HOLD HREF ON CONTENTS NODE
# session
#   GATE          dir self ==> return std::string root content (имя:тип)*
#   GATE          dir name ==> return std::string возвращает content корень текст имя:тип*
#   GATE          set name {[3,2,5]} ==> return string "" or error json""
#   GATE          set name name ==> связывает return string "" or error json""
#   GATE          get name ==> return JSON with state{}
#   GATE          new name name
#   GATE          del name
#   GATE          for name (name)+ ?numb ==> переводит gate в режим отсчета времени
#                     // это как sleep while not resource
#                     // все обращения и весь ввод со стороны приёмника будет возвращать GATE
#                     // <время>+<эхо последнего ввода for name (name)+>
#                     // 'break' 'break numb' or 'continue' or 'continue numb'
class gate:
    """
    КОНСОЛЬ БОТА, ДЛЯ КОВЫРЯНИИ В "QUERY_INTERFACE" "face" И В ЗНАЧЕНИЯХ НА СТОРОНЕ "gate".
    ОТКРЫТЬ ТАКОЙ "gate" МОЖНО, ТОЛЬКО ЕСЛИ ЕСТЬ TCP - порт открытый со стороны ПРИЛОЖЕНИЯ,
    ПРИЧИНА В ТОМ, ЧТО ЗАСТАВЛЯТЬ КАЖДОГО ПОЛЬЗОВАТЕЛЯ, ПРОИНСТАЛЛИРОВАТЬ НА СВОЙ СМАРТФОН,
    Python, НЕ СОВСЕМ РАЗУМНЫЙ МАРКЕТИНГОВЫЙ ХОД: Во первых понадеяться, что Python НОВОГО
    ОБРАЗЦА (старше 3.0) там ещё не стоит. Во вторых, наивно рассчитывать то пользователь,
    вообще начнет заниматься трудом сисадмина, ради игры TETRIS. - СКАЧАЕТ СЕБЕ ДРУГОЙ.
    """
    def __init__(self, host_port_tuple ):
        self.sess = session( host_port_tuple[0], host_port_tuple[1] )
    def refresh_timings(self):
        """это может быть хорошая команда обновить информацию об ожидаемых данных"""
        pass
    def dir(self, cmd_line):
        """GATE: dir name ==> возвращает содержание корня GATE (имя:тип)*"""
        echo = self.sess.send(cmd_line) 
        print "<dir><%s>%s" % (cmd_line, echo)
  
    def set(self, cmd_line):
        """
        GATE: set name {[3,2,5]} ==> return error descrition number or 0 - success
        GATE: set name.name o=> name.name ==> связывает узлы return string "" or error json
        """
        echo = self.sess.send(cmd_line)
        print "<set><%s>%s" % (cmd_line, echo)
  
  
  #GATE          get name ==> return JSON with state{}
  
  #GATE          new name name
  
  #GATE          del name
  
  #GATE          for name (name)+ ?numb ==> переводит gate в режим отсчета времени
  

def console():
    gx_sess = gate( global_host_port )
    linehead = ">"
    while(1):
        cmd_line = raw_input(linehead)
        cmd_line = cmd_line.strip()
        if not cmd_line:
            continue
        cmd = cmd_line.split(" ", 1)
        # print "<<%s>>" % cmd_line
        if cmd[0] == "exit":
            break;
        elif cmd[0] == "dir":
            if len(cmd) == 1:
                gx_sess.dir("")
            else:
                gx_sess.dir(cmd[1].strip())
            continue
        elif cmd[0] == "set":
            gx_sess.set(cmd[1].strip())
            continue
        print "<error>%s" % cmd_line

    

if __name__ == "__main__":
    # TESTS
    # print "json 001 result <%s>" % send_test_file("test_json_001.json")
    # print "json 002 result <%s>" % send_test_file("test_json_002.json")
    # send_random_numbers(20)
    console()
    